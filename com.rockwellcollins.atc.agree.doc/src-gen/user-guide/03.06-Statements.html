<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>AGREE User Guide</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">AGREE User Guide</h1>
</header>
<p>Developed with the sponsorship of Defense Advanced Research Projects Agency (DARPA).</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this data, including any software or models in source or binary form, as well as any drawings, specifications, and documentation (collectively “the Data”), to deal in the Data without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Data, and to permit persons to whom the Data is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Data.</p>
<p>THE DATA IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS, SPONSORS, DEVELOPERS, CONTRIBUTORS, OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE DATA OR THE USE OR OTHER DEALINGS IN THE DATA. )</p>
<h2 id="sec:statements">Statements</h2>
<p>In this section, we present the various types of AGREE statements and their uses. <strong>Note:</strong> <strong>Assume Statements (<a href="#sec:assume_statements">Assume Statements</a>) and Guarantee Statements (<a href="#sec:guarantee_statements">Guarantee Statements</a>) exclusively live in <em>component type</em>s; while Assert Statements (<a href="#sec:assert_statements">Assert Statements</a>) and Lemma Statements (<a href="#sec:lemma_statements">Lemma Statements</a>) exclusively live in <em>component implementation</em>s.</strong></p>
<h3 id="sec:assume_statements">Assume Statements</h3>
<p>Assume statements specify constraints about a component that are assumed to be true. An example of an assume statement is:</p>
<pre><code>assume A001 &quot;System input domain&quot; : Input &lt; 10;</code></pre>
<p>The string “System input domain” is used to identify the assumption when performing verification. The expression <code>Input &lt; 10</code> expresses the condition that is assumed to hold. When verifying a component implementation, the component’s assumptions are assumed to be true. However, the assumptions of the component implementation’s subcomponents must be proved to hold based on the assumptions of the component and the guarantees of other subcomponents.</p>
<p>The identifier <code>A001</code> names the the assume statement. Such names are optional and may be omitted. If a name is given it must be unique in the local namespace. Naming of specification statements is provided for integration with other tool suites such as requirements tracing.</p>
<h3 id="sec:guarantee_statements">Guarantee Statements</h3>
<p>Guarantee statements specify constraints that the component maintains as long as the assumptions have always held. An example of a guarantee statement is:</p>
<pre><code>guarantee G001 &quot;System output range&quot; : Output &lt; 50;</code></pre>
<p>The string “System output range” is used to identify the guarantee when performing verification. The expression <code>Output &lt; 50</code> expresses the condition that is guaranteed to hold.</p>
<p>When verifying a component implementation, guarantee statements are proven by the component assumptions and the guarantees present in subcomponent contracts.</p>
<p>The identifier <code>G001</code> names the the guarantee statement. Such names are optional and may be omitted. If a name is given it must be unique in the local namespace. Naming of specification statements is provided for integration with other tool suites such as requirements tracing.</p>
<h3 id="sec:equation_statements">Equation Statements</h3>
<p>Equation statements can be used to create local variable declarations within the body of an AGREE subclause. An example of an equation statement is:</p>
<pre><code>eq ctr : int = prev(ctr + 1, 0);</code></pre>
<p>In this example, we create a variable that counts up from zero. Variables defined with equation statements can be thought of as ‘’intermediate’’ variables or variables that are not meant to be visible in the architectural model (unlike component outputs or inputs). Equation statements can define variables explicitly by setting the equation equal to an expression immediately after it is defined. Equation statements can also define variables implicitly by not setting them equal to anything, but constraining them with assumption, assertion, or guarantee statements. Equation statements can define more than one variable at once by writing them in a comma delimited list. One might do this to constrain a list of variables to the results of a node statement that has multiple return values or to more cleanly list a set of implicitly defined variables.</p>
<h3 id="sec:property_statements">Property Statements</h3>
<p>Property statements allow specification of named Boolean expressions. An example property statement is:</p>
<pre><code>property not_system_start_implies_mode_0 =
not(OP_CMD_IN.System_Start) &gt; (GPCA_SW_OUT.Current_System_Mode = 0);</code></pre>
<p>Property statements are syntactic sugar (they are equivalent to defining an equation of type <strong>bool</strong>).</p>
<h3 id="sec:constant_statements">Constant Statements</h3>
<p>Constant statements allow definition of named constants. An example constant statement is:</p>
<pre><code>const ADS_MAX_PITCH_DELTA: real = 1.0 ;</code></pre>
<p>Identifiers defined by constant statements are used just like equation variables.</p>
<h3 id="sec:node_definitions">Node Definitions</h3>
<p>Node statements are used to define stateful ‘’functions’’ that might be used frequently in a component type or implementation. Nodes can have multiple return values. If this is the cause, they must be referenced by an equation statement that has multiple arguments. Nodes can also be defined in an AADL Package. If so, they can be referenced in any expression anywhere in the model. This way one can make a library of certain types of nodes that are useful for different tasks.</p>
<p>Node definitions in AGREE allow specification of <em>stateful</em> definitions; that is, definitions that can maintain internal state. An example node for maintaining a generalized counter would be:</p>
<pre><code>node Counter(init: int, incr: int, reset: bool)  
returns (count: int);  
let  
    count = if reset then init  
        else prev(count, init) + incr;  
tel;</code></pre>
<p>In this example, if reset is true, the counter is reset back to the init value. Otherwise, it increments by incr. The node maintains state (the value of count changes from time step to time step). It is then possible to instantiate this node in other expressions. For example:</p>
<pre><code>eq x1 : int = Counter(0, 1, prev(x1 = 9, false));

eq x2 : int = Counter(1, prev(x2, 0),false);</code></pre>
<p>Given these equations, <code>x1</code> is a counter that repeatedly counts up to 9 then resets to zero, and <code>x2</code> computes the Fibonacci series.</p>
<p>An example of a more complex node with multiple nodes, multiple outputs and local variables would be a 4-bit adder:</p>
<pre><code>node ADD1(a : bool, b : bool, carry_in : bool)
returns (out : bool, carry_out : bool);
let
    out = (a &lt;&gt; b) &lt;&gt; carry\in;
    carry_out = (a and b) or (a and carry_in) or (b and carry_in);
tel;

node ADD4 (a0 : bool, a1 : bool, a2 : bool, a3 : bool,
           b0 : bool, b1 : bool, b2 : bool, b3 : bool)
returns (s0 : bool, s1 : bool, s2 : bool, s3 : bool, carry_out : bool);
var c0 : bool;
    c1 : bool;
    c2 : bool;
    c3 : bool;
let
    s0,c0 = ADD1(a0, b0, false);
    s1,c1 = ADD1(a1, b1, c0);
    s2,c2 = ADD1(a2, b2, c1);
    s3,c3 = ADD1(a3, b3, c2);
    carry_out = c3;
tel;</code></pre>
<p>The ADD1 node takes two single bit inputs and a carry input bit and computes an output and a carry bit. We can use this to create a four-bit adder <code>ADD4</code> by “stringing together” four of the one-bit adders. Note that all local variables (defined with <strong>var</strong>) and all output variables (defined in the <strong>returns</strong> section) must be assigned exactly one time within the <strong>let</strong> block.</p>
<p><strong>Note</strong>: Nodes cannot be recursive or mutually recursive.</p>
<h3 id="sec:record_definitions">Record Definitions</h3>
<p>Record definitions are used to define record types. Like a struct type in C programming language, a record is a collection of fields, each of its own data type. An example record definition is as follows:</p>
<pre><code>type foo = struct {a : bool, b : int};</code></pre>
<h3 id="sec:real_time_patterns">Real-time Patterns</h3>
<p>AGREE also supports the specifications of real-time patterns. These patterns were adopted from the Requirements Specification Language adopted under the CESAR project. Patterns can be used instead of expressions in Assume, Guarantee, or Assert statements. The grammar for the patterns that we support is shown below:</p>
<pre><code>PatternStatement:
  WheneverStatement
  | WhenStatement
  | RealTimeStatement
  ;

WhenStatement:
  &#39;when&#39; Expr &#39;holds&#39; &#39;during&#39; TimeInterval Expr
  (&#39;exclusively&#39;)? &#39;occurs&#39; &#39;during&#39; TimeInterval
  ;

WheneverStatement:
  &#39;whenever&#39; Expr &#39;occurs&#39; Expr
    (&#39;exclusively&#39;)? (&#39;occur&#39; | &#39;occurs&#39;)) &#39;during&#39; TimeInterval
  | &#39;whenever&#39; Expr &#39;occurs&#39; Expr
    (&#39;exclusively&#39;)? (&#39;holds&#39;) &#39;during&#39; TimeInterval
  | &#39;whenever&#39; Expr &#39;occurs&#39; Expr &#39;implies&#39; Expr
    (&#39;exclusively&#39;)? &#39;during&#39; TimeInterval
  ;

RealTimeStatement:
  &#39;condition&#39; Expr &#39;occurs&#39; &#39;each&#39; Expr (&#39;with&#39; &#39;jitter&#39; jitter=Expr)?
  | &#39;condition&#39; Expr &#39;occurs&#39; &#39;sporadic&#39; &#39;with&#39; &#39;IAT&#39; Expr
    (&#39;with&#39; &#39;*jitter*&#39; jitter=Expr)?
  ;

TimeInterval:
  &#39;\[ | (&#39; Expr &#39;,&#39; Expr &#39;\] | )&#39;)
  ;</code></pre>
<p>The expressions in each of the patterns must be an IDExpr (a variable without any dots) of Boolean type. Details about the semantics of these patterns, how they are implemented, and how they may be used can be found in the Final Documentation and Technical Report for the Requirements Patterns for Formal Contracts in AADL program.</p>
<p>The time intervals specified by these patterns reference values for a reserved variable named “time”. This variable is present in any counterexamples or inductive counterexamples that the tool produces. Additionally, AGREE contains three special functions that take a single IDExpr as an argument and produce a value of type real. These functions are:</p>
<ol type="1">
<li><p>timeof(id) – returns the the last value of the variable time in which id was true. If id has never been true then the function returns the value -1.0.</p></li>
<li><p>timerise(id) – returns the last value of the variable time in which id transitioned to true. If id has never been true then the function returns the value -1.0.</p></li>
<li><p>timefall(id) – returns the last value of the variable time in which id transitioned to false. If id has never been false then the function returns the value -1.0.</p></li>
</ol>
<h3 id="sec:assert_statements">Advanced Topic: Assert statements</h3>
<p>Assert statements allow definition of axioms within the model. Axioms are “facts” about the behavior of the system or the environment that are added to the model to support proofs. An example assertion is of the form:</p>
<pre><code>assert AS001 : (FGS_L.LSO.Valid and FGS_R.LSO.Valid) &gt; FGS_L.LSO.Leader = FGS_R.LSO.Leader;</code></pre>
<p>Assertions are sometimes used for <em>architectural</em> <em>patterns</em> whose correctness is established in a separate phase of analysis. The assertion above is from a pattern called <em>leader selection</em> that ensures that one of a set of redundant components is the leader.</p>
<p>Assert statements make unchecked statements about how the component behaves. These are also used to reference variables from a subcomponent in the component contract. For the purpose of analysis assertions are treated just like the system assumptions. However, AGREE never verifies that the assertions actually hold. That is to say, the assertions of a subcomponent are never proven to hold like subcomponent assumptions. Assert statements can refer to equations or features defined in the component type. They are often used to refer to subcomponent variables in contracts higher up in the model hierarchy.</p>
<p><strong>Note: Assert statements are assumed to be true and are not validated in any way by AGREE. Any use of this statement should be exercised with great caution. All assert statements should be examined by a domain expert and formal verification expert.</strong></p>
<p>The identifier <code>AS001</code> names the the assert statement. Such names are optional and may be omitted. The separating colon is also omitted in this case. If a name is given it must be unique in the local namespace. Naming of specification statements is provided for integration with other tool suites such as requirements tracing.</p>
<h3 id="sec:lemma_statements">Advanced Topic: Lemma Statements</h3>
<p>Assert statements are used to introduce lemmas to assist the model checker when performing verification. AGREE uses <em>k-induction over the transition relation</em> to try to prove properties – see Appendix A for a high-level description of the procedure. For many systems and properties, this works very well and is able to prove interesting properties about the system without assistance. However, sometimes a property is <em>true</em> but not <em>provable</em> using this technique. The reason that this happens is the property to be proved is too weak to be inductively provable. Lemma statements are additional properties that are added to an AGREE model in order to <em>strengthen</em> the property to be proved.</p>
<p>An example lemma would be:</p>
<pre><code>lemma L001 &quot;drug flow lemma&quot; :
    (not drug_flow_stopped) =&gt; spo2_never_below_thresh;</code></pre>
<p>From the perspective of proof, lemmas behave the same as guarantees; they must be proven by AGREE. These are used to help the model checker learn facts to improve its ability to prove other properties. However, unlike guarantees, lemmas are not made visible when trying to prove properties at the next level of abstraction. Subcomponent lemmas are not used to prove other subcomponent guarantees or system guarantees.</p>
<p>The identifier <code>L001</code> names the the lemma statement. Such names are optional and may be omitted. If a name is given it must be unique in the local namespace. Naming of specification statements is provided for integration with other tool suites such as requirements tracing.</p>
<h3 id="sec:reachable_statements">Advanced Topic: Reachable Statements</h3>
<p>Reachable statements may be used to check for vacuity of a guarantee or lemma statement. The typical use is where a guarantee statement is written in the form of an implication. The reachable statement may be used to check that the antecedent (the left hand side) of the guarantee statement is reachable in at least one possible combination of inputs to the model.</p>
<p>Like lemma statments, reachable statements do not affect the compositional contract analysis, but may assist the model checker when performing verification. That is, reachable statements are not used to prove other subcomponent guarantees or system guarantees.</p>
<p>An example would be:</p>
<pre><code>reachable R001 &quot;drug flow might not be stopped&quot; :
    (not drug_flow_stopped);</code></pre>
<p>The identifier <code>R001</code> names the the lemma statement. Such names are optional and may be omitted. If a name is given it must be unique in the local namespace. Naming of specification statements is provided for integration with other tool suites such as requirements tracing.</p>
<h3 id="sec:linearization_definitions">Advanced Topic: Linearization Definitions</h3>
<p>The linearization definition provides the declaration of a linear approximation of a non-linear expression over segment(s) of its input domain, resulting in a new expression that bounds the non-linear expression with piecewise linear segment(s). The non-linear expression supports a small core of mathematical functions found on a calculator (i.e., ‘+’, ‘-’, ‘*’, ‘/’, ‘^’) and a collection of transcendental mathematical functions. <strong>Note</strong>: The non-linear expression can contain references to only the input variable (no other AGREE identifiers). Figure <a href="#fig:linearization_definition">1</a> demonstrates a linear approximation bounding the output values within the upper and lower bounds.</p>
<figure>
<img src="../../media/image13.png" id="fig:linearization_definition" class="class" style="width:90.0%" alt="Figure 1: Bound Non-linear Expression with Piecewise Linear Segments" /><figcaption aria-hidden="true">Figure 1: Bound Non-linear Expression with Piecewise Linear Segments</figcaption>
</figure>
<p>The following linearization definition example provides the linear approximation for the square operation with a real type input over input interval between -1.0 and 1.0, and input precision of 0.01.</p>
<pre><code>linearization sq (y : real) over [-1.0 .. 1.0] within 0.01 : y^2.0;</code></pre>
<p><strong>Note: Currently linearization definition with single input of real type is supported. </strong></p>
<p>The following function calls are allowed within the linearization body expression:</p>
<blockquote>
<p>abs, acos, asin, atan, cbrt, cos, cosh, exp, expml, log, log10, log1p, signum, sin, sinh, sqrt, tan, and tanh.</p>
</blockquote>
<h3 id="sec:uninterpreted_functions">Advanced Topic: Uninterpreted Functions</h3>
<p>AGREE supports the specification of uninterpreted functions (UF). A UF does not define the meaning of the function, instead it allows the underlying SMT solver to define the mapping. The only fundamental constraint is that each element in the <em>domain</em> maps to a single element in the <em>range</em>. That is,</p>
<pre><code>if x = y then f(x) = f(y).</code></pre>
<p>The grammar for UF that AGREE supports is shown below:</p>
<pre><code>UninterpretedFnDef:
    &#39;uninterpreted&#39; name=ID &#39;(&#39; args+=Arg (&#39;,&#39; args+=Arg)* &#39;)&#39; 
             &#39;:&#39; type=Type &#39;;&#39;;</code></pre>
<p>An example of a UF definition is:</p>
<pre><code>uninterpreted sincos(x: real) : real;</code></pre>
<p>The definition is similar to a regular function except that there is no function body. Once a UF is defined, it can be called the same way as a regular function. A UF could have multiple inputs, but can only have one output. AGREE support UF with record type inputs and output. If a UF with multiple outputs is desired, a record type output could be used. Note that AGREE does not support UF with no inputs.</p>
<p>If a property fails in AGREE verification, in addition to the counterexample, AGREE will also generate uninterpreted function tables. The tables show how the functions were “interpreted” by the underlying SMT solver. The values in the table should match the values used in the counterexample. Currently AGREE supports display of UF in console and spreadsheet view, but not Eclipse view. Figure <a href="#fig:uf_console">2</a> and Figure <a href="#fig:uf_eclipse">3</a> show a UF in console and spreadsheet view, respectively.</p>
<figure>
<img src="../../media/image32.png" id="fig:uf_console" class="class" style="width:90.0%" alt="Figure 2: Display of an Uninterpreted Function in Console View Segments" /><figcaption aria-hidden="true">Figure 2: Display of an Uninterpreted Function in Console View Segments</figcaption>
</figure>
<figure>
<img src="../../media/image33.png" id="fig:uf_eclipse" class="class" style="width:90.0%" alt="Figure 3: Display of an Uninterpreted Function in Spreadsheet View Segments" /><figcaption aria-hidden="true">Figure 3: Display of an Uninterpreted Function in Spreadsheet View Segments</figcaption>
</figure>
</body>
</html>
