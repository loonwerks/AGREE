<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>AGREE User Guide</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">AGREE User Guide</h1>
</header>
<h2 id="sec:agree_osate_main_features">Main Features</h2>
<p>In this section we walk through the main features involved with the AGREE tool suite.</p>
<h3 id="sec:import-existing-projects">Import Existing Projects</h3>
<p>To import an existing project into AGREE, users need to first select “Import” through the File menu as shown in Figure <a href="#fig:import_project_from_file_menu">1</a>. This will open an Import dialog box, as shown in Figure <a href="#fig:import_project_dialog">2</a>. From there, users can choose to import from different sources. This section presents a few most commonly used sources. After the import project selection is done, you should see the project in the AADL Navigator in the left-hand-side pane in OSATE.</p>
<figure>
<img src="../../media/image23.png" id="fig:import_project_from_file_menu" style="width:1.9375in;height:2.92546in" alt="Figure 1: Import Project from the File Menu" /><figcaption aria-hidden="true">Figure 1: Import Project from the File Menu</figcaption>
</figure>
<p><strong>Import Archived Projects.</strong> To import an archived project (previously exported project in the form of a zip or tar file format), choose “Existing Projects into Workspace” under the “General” category from the Import Dialog box in Figure <a href="#fig:import_project_dialog">2</a> and click “Next”. Choose “Select archive file”, navigate to the location and select the archived project file, and click “Finish”. An example is shown in Figure <a href="#fig:import_archived_projects">3</a>.</p>
<figure>
<img src="../../media/image24.png" id="fig:import_project_dialog" style="width:3.33333in;height:3.48513in" alt="Figure 2: Import Dialog Box" /><figcaption aria-hidden="true">Figure 2: Import Dialog Box</figcaption>
</figure>
<figure>
<img src="../../media/image25.png" id="fig:import_archived_projects" style="width:3.125in;height:4.09628in" alt="Figure 3: Import Archived Projects" /><figcaption aria-hidden="true">Figure 3: Import Archived Projects</figcaption>
</figure>
<p><strong>Import Projects from a Directory.</strong> To import a project from a directory, choose “Existing Projects into Workspace” under the “General” category from the Import Dialog box in Figure <a href="#fig:import_project_dialog">2</a> and click “Next”. Choose “Select root directory”, navigate to the location and select the project folder, and click “Finish”. An example is shown in Figure <a href="#fig:import_projects_from_directory">4</a>.</p>
<figure>
<img src="../../media/image26.png" id="fig:import_projects_from_directory" style="width:4.02083in;height:5.19935in" alt="Figure 4: Import Projects from a Directory" /><figcaption aria-hidden="true">Figure 4: Import Projects from a Directory</figcaption>
</figure>
<p><strong>Import Git Projects.</strong> To import a project from Git, choose “Projects from Git” under the “Git” category from the Import Dialog box in Figure <a href="#fig:import_project_dialog">2</a> and click “Next”. Choose the “Existing local repository”, then select a local repository that contains the projects, and explore to the specific project folder to import.</p>
<p><strong>Note</strong>: Example projects with AGREE contracts in the AADL models can be obtained from the <a href="https://github.com/smaccm/smaccm/tree/master/models">SMACCM Git repository</a>. These files are from GitHub and could be retrieved via the Git configuration control tool. More information about the Git tool and the download information can be found at <a href="https://git-scm.com/">Git-SCM</a>.</p>
<h3 id="sec:create-new-projects">Create New Projects</h3>
<p>After started OSATE, the AADL perspective should be the default. If not, the AADL perspective can be selected via selecting the “Window” menu -&gt; “Perspective” -&gt; “Open Perspective” -&gt; “Other…” -&gt; “AADL”. (See the “AADL” text on the upper right corner of the OSATE window as shown in <a href="04.02-Installation.html#fig:agree_install_test">Agree Install Test</a>.)</p>
<p>Create a new AADL project by selecting the “File” menu -&gt; “New” -&gt; “Project…”, and select “AADL Project” under the “AADL” category. An example is shown in Figure <a href="#fig:create_new_aadl_project_dialog">5</a>. More detailed information about creating AADL models in a project can be found at <a href="https://wiki.sei.cmu.edu/aadl/index.php/Editing_a_first_AADL_model">Editing a First AADL Model</a>.</p>
<figure>
<img src="../../media/image27.png" id="fig:create_new_aadl_project_dialog" style="width:4.78125in;height:4.4305in" alt="Figure 5: Create a New AADL Project" /><figcaption aria-hidden="true">Figure 5: Create a New AADL Project</figcaption>
</figure>
<h3 id="sec:verify-contracts">Verify Contracts</h3>
<p>As described in the previous chapters, each of the system and component contracts in AGREE are formalized as Assumptions and Guarantees. A component’s contracts contain a set of Assumptions about the component’s inputs and a set of Guarantees about the component’s outputs. The Assumptions and Guarantees may also contain predicates that reason about how the state of a component evolves over time.</p>
<p>The goal of compositional verification is to prove that each component’s contract is satisfied by the interaction of its direct subcomponents as described by their respective contracts. Users can start the verification by selecting a system implementation of a component in the outline pane on the right side of OSATE, and select either the “Verify Single Layer” or the “Verify All Layers” option from the right-click menu (shown in <a href="02.00-Brief-Overview-of-AADL-and-AGREE.html#fig:verify_all_layers_from_right_click">Verify All Layers from Right Click</a>) or the AGREE menu (shown in <a href="02.00-Brief-Overview-of-AADL-and-AGREE.html#fig:verify_all_layers_from_agree_menu">Verify All Layers from AGREE Menu</a>). As the names suggest, “Verify Single Layer” performs verification at the current layer of the architecture hierarchy, while “Verify All Layers” performs verification at the current layer and each layer below. For a given layer of the architecture, the verification uses the Assumptions and Guarantees of the direct lower level components as supporting evidence, to prove if the Assumptions and Guarantees at the current layer are satisfied.</p>
<p>Another verification option that is available through the right-click menu or AGREE menu when selecting a system implementation is “Verify Monolithically”. This option utilizes Assumptions and Guarantees not only from the direct subcomponents at the lower level, but from components all levels below as evidence for the verification. This is needed when the constraints imposed by components lower in the hierarchy are needed in the proof, so users do not need to manually copy the Assumptions and Guarantees from those lower level components up to their parent components in the hierarchy.</p>
<p>To help clarify the difference between the co-verification options, consider the picture in Figure <a href="#fig:a_hierarchical_model">6</a>. In this Figure, the blocks represent AADL system implementations for different components. In compositional verification (“Verify Single Layer” and “Verify All Layers”), AGREE will only use the Assumptions and Guarantees of component 2 and 3 as evidence (<code>A</code><sub><code>2</code></sub>, <code>G</code><sub><code>2</code></sub>, <code>A</code><sub><code>3</code></sub>, and <code>G</code><sub><code>4</code></sub>) to prove the Assumptions and Guarantees of component 1 (<code>A</code><sub><code>1</code></sub> and <code>G</code><sub><code>1</code></sub>); the tool ignore any of the constraints posed by components 4 through 7. Monolithical verification, on the other hand, will use Assumptions and Guarantees of components 2 through 7 to prove the Assumptions and Guarantees of component 1.</p>
<p>The philosophy of the compositional verification option is that component contracts should yield the minimum constraints necessary in order to prove the guarantees of the direct parents. This aids the model checker by explicitly hiding information that may be unnecessary to prove top level claims. Compositional verification should be used as the default verification option with AGREE.</p>
<figure>
<img src="../../media/image28.png" id="fig:a_hierarchical_model" class="class" style="width:80.0%" alt="Figure 6: A Hierarchical Model" /><figcaption aria-hidden="true">Figure 6: A Hierarchical Model</figcaption>
</figure>
<p><strong>Note 1</strong>: Details of lower level components (e.g., implementation details besides the assumptions and guarantees on the interface of the components) are abstracted away during verification of higher level component contracts.</p>
<p><strong>Note 2</strong>: Component contracts at the lowest level of the architecture are assumed to be true by AGREE. Verification of these component contracts must be performed outside of the AADL/AGREE environment, as demonstrated in <a href="#sec:agree_to_simulink_exporter">AGREE to Simulink Exporter</a>.</p>
<p>When the verification starts, a results view appears at the bottom of the screen with the status of all the contracts being checked. Results for each component are grouped by guarantees, assumptions, and consistency. The consistency check verifies if the composition of the subcomponents are consistent, and if the contracts being analyzed for a component is consistent. For example, it checks if the conjunction of a system’s guarantees is satisfiable.</p>
<p>If a counterexample for a contract is found then it will have a red icon next to it in the results dialog. Right-clicking on one of these results will bring up a menu where you can choose to view the counterexample in the console, in a spreadsheet, or in a collapsible menu.</p>
<p><strong>Note</strong>: Some Guarantees may take longer than the set analysis time to produce a “Valid” or “Invalid” result. In such a case, users may extend the timeout time (e.g., from 100 seconds to 1000 seconds) and/or enlarge the maximum depth for k-induction to use, in OSATE “Window” menu -&gt; “Preferences” -&gt; “Agree” -&gt; “Analysis”, as shown in <a href="04.02-Installation.html#fig:smt_solver_selection">SMT Solver Selection</a>.</p>
<h3 id="sec:check-realizability">Check Realizability</h3>
<p>The need for the realizability checking can be motivated through the following example. In the Microwave AADL model, the following two requirements were imposed:</p>
<p><em>Requirement 1: While the microwave is in cooking mode, seconds_to_cook shall decrease.</em></p>
<p><em>Requirement 2: If the display is quiescent (no buttons pressed) and the keypad is enabled, the seconds_to_cook shall not change.</em></p>
<p>On input conditions that satisfy both requirements (i.e., when the microwave is in cooking mode, the display is quiescent and the keypad is enabled), there is a conflict in the value of the seconds_to_cook variable, resulting in the two requirements not being able to be satisfied at the same time in those input conditions.</p>
<p>Realizability checking determines whether or not the component works in all input environments that satisfy the component assumptions. It can be invoked by selecting the system implementation of a component in the outline pane on the right side of OSATE, and select either the “Check Realizability” from the right-click menu (shown in <a href="02.00-Brief-Overview-of-AADL-and-AGREE.html#fig:verify_all_layers_from_right_click">Verify All Layers from Right Click</a>) or the AGREE menu (shown in <a href="02.00-Brief-Overview-of-AADL-and-AGREE.html#fig:verify_all_layers_from_agree_menu">Verify All Layers from AGREE Menu</a>).</p>
<h3 id="sec:agree_to_simulink_exporter">AGREE/AADL to Simulink Exporter</h3>
<p>Component contracts at the lowest level of the architecture are assumed to be true by AGREE. Verification of these component contracts must be performed outside of the AADL/AGREE environment. The Exporter feature automatically exports the AGREE contracts into properties in a MATLAB function. The MATLAB function can be connected to the component’s Simulink model and serves as a synchronous observer for its behavior. Simulink Design Verifier can be invoked to check if the component’s Simulink model satisfies the properties exported.</p>
<p>The Exporter feature works with two Simulink models: the implementation model, which contains the subsystem that encapsulates the behavior of the component, and a verification model, which connects the exported AGREE contracts to the implementation.</p>
<p>The implementation model can be auto-generated from the AADL model, if desired, or can be manually created. When auto-generated it contains the inputs and outputs specified in the AADL model and an empty subsystem, ready for the modeler to insert the behavioral logic into. The auto-generated model should be hand edited to contain the implementation of the behavioral aspects of the component, and can be used to generate the code for the target.</p>
<p>The verification model uses the implementation model (as a Simulink model reference block) to create a model suitable for verification. It creates an observer block to wrap the MATLAB function that contains the AGREE contracts as MATLAB properties. It also creates input and output ports according to the AADL model, instantiates a reference to the implementation model, and connects the observer block to the implementation model. The verification model is not suitable for code generation for the target, but is suitable for verification of the implementation. Since the model being verified is a model reference (and not a copy), formal credit may be taken from the verification activity.</p>
<p>The Exporter does not directly generate Simulink models, but rather generates MATLAB scripts which will generate the models. This allows the exporter to remain largely isolated from issues associated with Simulink versions, as well as providing visibility to the model generation actions should it be necessary for debugging purposes.</p>
<p>The Exporter automatically updates the AADL model with the appropriate path and file name information via the “Source_Text” AADL property. This associates the information of the component implementation in the design model, and allows users to proceed directly to action selection in subsequent exports, if no changes to the saved information.</p>
<p>Note that Real-time patterns (as seen in <a href="03.06-Statements.html#sec:real_time_patterns">Real Time Patterna</a>) in AGREE cannot be exported to MATLAB functions, and should not be. These patterns refer to the scheduling and performance of the component, rather than its specific behavior. Thus, the model will need to be decomposed further (i.e., so the real-time constraints will be turned into behavioral constraints on each individual component’s inputs and outputs) before generating a Simulink implementation.</p>
<p>To use the Exporter feature, follow the steps below:</p>
<p>1. Specify the data type to be mapped from AGREE to Simulink through the “Window” menu -&gt; “Preferences” -&gt; “Agree” -&gt; “Code Generation”. Users may select one of the MATLAB supported integer types (i.e., (u)int8, (u)int16, (u)int32, (u)int64) to represent integers in AGREE and one of the MATLAB supported floating point types (i.e., single, double) to represent reals in AGREE. Note that this option only applies to the abstract “integer” and “real” AADL types; concrete types with a size specification are automatically mapped to the corresponding MATLAB type;</p>
<p>2. Select the system implementation of the component whose contracts are to be exported, and select the “Generate Simulink Models” option in either the right-click menu (shown in <a href="02.00-Brief-Overview-of-AADL-and-AGREE.html#fig:verify_all_layers_from_right_click">Verify All Layers from Right Click</a>) or the AGREE menu (shown in <a href="02.00-Brief-Overview-of-AADL-and-AGREE.html#fig:verify_all_layers_from_agree_menu">Verify All Layers from AGREE Menu</a>).</p>
<p>3. The dialog box shown in Figure <a href="#fig:general_simulink_models_dialog">7</a> will be presented. After completing the data fields, select the activity to be performed by clicking on one of the action buttons. The fields and actions are described in detail below.</p>
<figure>
<img src="../../media/image29.png" id="fig:general_simulink_models_dialog" class="class" style="width:90.0%" alt="Figure 7: General Simulink Models Dialog" /><figcaption aria-hidden="true">Figure 7: General Simulink Models Dialog</figcaption>
</figure>
<p><strong><em>Output Directory Path</em></strong>: This is the location of the exported MATLAB scripts that, when executed, will actually generate the Simulink models (either the implementation or verification model).</p>
<p><strong><em>Implementation Model Path</em></strong>: This is the location of the implementation model in Simulink. If the model does not exist, the script can generate an empty subsystem with the interface consistent with the AADL model. Note that the implementation model must exist before the verification model can be generated. If the inputs/outputs to the implementation model contain aggregate types or structured data, these IO data will be represented in Simulink by bus objects. These bus objects are auto saved in a file with a filename of the form “&lt;ImplementationModel&gt;_busobjs.m” in this directory.</p>
<p><strong><em>Verification Model Name</em></strong>: This is the file name for the verification model that will be generated. It will be placed in the output directory specified above.</p>
<p><strong><em>Subsystem to Verify</em></strong>: This is the name of the subsystem in the verification model that the observer block connects to. The subsystem contains the implementation logic for the chosen component. An auto generated implementation model will contain only the subsystem named after the text entered in this field. A manually created implementation model may contain multiple subsystems, and the subsystem name entered in the field selects the specific subsystem to verify.</p>
<p><strong><em>Export Contracts</em></strong> – This button will generate the MATLAB script containing the AGREE contracts, translated into MATLAB properties. This script will be wrapped inside an observer block in the generated Verification model. The script will be placed in the Output Directory.</p>
<p><strong><em>Generate Implementation</em></strong> – This button will generate the script to create an implementation model. When the script is running in MATLAB, an error will be reported if the implementation model already exists. The script will be placed in the Output Directory.</p>
<p>The implementation model is considered non-overwritable (and will not be overwritten with an export). If users wish to regenerate the implementation model, they will first need to delete the existing model (and its bus object storage file, if applicable).</p>
<p><strong><em>Generate Verification</em></strong> – This button will generate the script containing the AGREE contracts (as in <em>Export Contracts</em>) as well as the script to create a verification model. The generated scripts will be placed in the Output Directory.</p>
<p>The verification model is considered overwriteable and can be regenerated at-will. This is because the verification model contains no logic that is not already captured in other locations (the AGREE contracts or the implementation model contents). If the AGREE contracts (but not the inputs/outputs) are changed, users can click this button to regenerate the verification model with the new contracts.</p>
<p><strong><em>Verify Subsystem</em></strong> – This button will generate the script containing the AGREE contracts (as in Export Contracts), as well as the script to create a verification model (as in Generate Verification) and run Simulink Design Verifier on the generated verification model. Note that Design Verifier can still be run from the Simulink environment as needed – the generated script automates all the steps needed to verify an implementation model against its AGREE contracts, completing the verification workflow.</p>
</body>
</html>
