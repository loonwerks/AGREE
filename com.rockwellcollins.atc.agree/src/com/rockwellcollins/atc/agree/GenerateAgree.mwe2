/*
 * Copyright (c) 2022, Collins Aerospace.
 * Developed with the sponsorship of Defense Advanced Research Projects Agency (DARPA).
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this data, 
 * including any software or models in source or binary form, as well as any drawings, specifications, 
 * and documentation (collectively "the Data"), to deal in the Data without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Data, and to permit persons to whom the Data is furnished to do so, 
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or 
 * substantial portions of the Data.
 * 
 * THE DATA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 * IN NO EVENT SHALL THE AUTHORS, SPONSORS, DEVELOPERS, CONTRIBUTORS, OR COPYRIGHT HOLDERS BE LIABLE 
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE DATA OR THE USE OR OTHER DEALINGS IN THE DATA.
 */
module com.rockwellcollins.atc.agree.GenerateAgree

import org.eclipse.emf.mwe.utils.*
import org.eclipse.xtext.xtext.generator.*
import org.eclipse.xtext.xtext.generator.model.project.*

//var grammarURI = "classpath:/com/rockwellcollins/atc/agree/Agree.xtext"
//var file.extensions = "agree"
var projectName = "com.rockwellcollins.atc.agree"
var runtimeProject = "../${projectName}"

var agreeFileHeader = "/*
 * Copyright (c) \${year}, Collins Aerospace.
 * Developed with the sponsorship of Defense Advanced Research Projects Agency (DARPA).
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this data, 
 * including any software or models in source or binary form, as well as any drawings, specifications, 
 * and documentation (collectively \"the Data\"), to deal in the Data without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Data, and to permit persons to whom the Data is furnished to do so, 
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or 
 * substantial portions of the Data.
 * 
 * THE DATA IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 * IN NO EVENT SHALL THE AUTHORS, SPONSORS, DEVELOPERS, CONTRIBUTORS, OR COPYRIGHT HOLDERS BE LIABLE 
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE DATA OR THE USE OR OTHER DEALINGS IN THE DATA.
 *
 * Generated by Xtext version \${version}.
 */\n\n"

Workflow {
	bean = StandaloneSetup {
		scanClassPath = true
		platformUri = "${runtimeProject}/.."
		uriMap = {
			from = "platform:/plugin/org.eclipse.emf.codegen.ecore/model/GenModel.genmodel"
			to = "platform:/resource/org.eclipse.emf.codegen.ecore/model/GenModel.genmodel"
		}
		uriMap = {
			from = "platform:/plugin/org.eclipse.emf.ecore/model/Ecore.genmodel"
			to = "platform:/resource/org.eclipse.emf.ecore/model/Ecore.genmodel"
		}
		uriMap = {
			from = "platform:/plugin/org.eclipse.uml2.codegen.ecore/model/GenModel.genmodel"
			to = "platform:/resource/org.eclipse.uml2.codegen.ecore/model/GenModel.genmodel"
		}
		uriMap = {
			from = "platform:/plugin/org.eclipse.uml2.types/model/Types.genmodel"
			to = "platform:/resource/org.eclipse.uml2.types/model/Types.genmodel"
		}
		uriMap = {
			from = "platform:/plugin/org.eclipse.uml2.uml/model/UML.genmodel"
			to = "platform:/resource/org.eclipse.uml2.uml/model/UML.genmodel"
		}
		uriMap = {
			from = "platform:/plugin/org.eclipse.emf.codegen.ecore/model/GenModel.ecore"
			to = "platform:/resource/org.eclipse.emf.codegen.ecore/model/GenModel.ecore"
		}
		uriMap = {
			from = "platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore"
			to = "platform:/resource/org.eclipse.emf.ecore/model/Ecore.ecore"
		}
		uriMap = {
			from = "platform:/plugin/org.eclipse.uml2.codegen.ecore/model/GenModel.ecore"
			to = "platform:/resource/org.eclipse.uml2.codegen.ecore/model/GenModel.ecore"
		}
		uriMap = {
			from = "platform:/plugin/org.eclipse.uml2.types/model/Types.ecore"
			to = "platform:/resource/org.eclipse.uml2.types/model/Types.ecore"
		}
		uriMap = {
			from = "platform:/plugin/org.eclipse.uml2.uml/model/UML.ecore"
			to = "platform:/resource/org.eclipse.uml2.uml/model/UML.ecore"
		}
		//
		registerGeneratedEPackage = "org.eclipse.emf.ecore.EcorePackage"
		registerGeneratedEPackage = "org.eclipse.uml2.types.TypesPackage"
		registerGeneratedEPackage = "org.eclipse.uml2.uml.UMLPackage"
		registerGeneratedEPackage = "org.eclipse.emf.codegen.ecore.genmodel.GenModelPackage"
		registerGeneratedEPackage = "org.eclipse.uml2.codegen.ecore.genmodel.GenModelPackage"
		registerGenModelFile = "platform:/resource/org.eclipse.emf.ecore/model/Ecore.genmodel"
		registerGenModelFile = "platform:/resource/org.eclipse.emf.codegen.ecore/model/GenModel.genmodel"
		registerGenModelFile = "platform:/resource/org.eclipse.uml2.types/model/Types.genmodel"
		registerGenModelFile = "platform:/resource/org.eclipse.uml2.uml/model/UML.genmodel"
		registerGenModelFile = "platform:/resource/org.eclipse.uml2.codegen.ecore/model/GenModel.genmodel"
		registerGeneratedEPackage = "org.osate.aadl2.Aadl2Package"
		registerGenModelFile = "platform:/resource/org.osate.aadl2/model/aadl2.genmodel"
		//registerGenModelFile = "platform:/resource/org.eclipse.xtext.common.types/model/JavaVMTypes.genmodel"
	}

	component = DirectoryCleaner {
		directory = "${runtimeProject}/src-gen"
	}

	component = DirectoryCleaner {
		directory = "${runtimeProject}.ui/src-gen"
	}

	component = DirectoryCleaner {
		directory = "${runtimeProject}.tests/src-gen"
	}

	component = XtextGenerator {
		configuration = {
			project = StandardProjectConfig {
				baseName = projectName
				rootPath = ".."
				runtimeTest = {
					enabled = false
				}
				genericIde = {
					name = "${projectName}.ui"
				}
				eclipsePlugin = {
					enabled = true
				}
				eclipsePluginTest = {
					enabled = false
				}
				createEclipseMetaData = true
			}
			code = {
				preferXtendStubs = false
				encoding = "UTF-8"
				lineDelimiter = "\n"
				fileHeader = agreeFileHeader
			}
		}
		language = XtextGeneratorLanguage {
			name = "com.rockwellcollins.atc.agree.Agree"
			fileExtensions = "agree"

			// Java API to access grammar elements (required by several other fragments)
			fragment = grammarAccess.GrammarAccessFragment2 {}

			// generates Java API for the generated EPackages 
			fragment = ecore.EMFGeneratorFragment2 {}

			fragment = serializer.SerializerFragment2 {}

			fragment = resourceFactory.ResourceFactoryFragment2 {}

			fragment = parser.antlr.XtextAntlrGeneratorFragment2 {
				options = {
					classSplitting = true
					ignoreCase = true
				}
			}
			fragment = ecore2xtext.Ecore2XtextValueConverterServiceFragment2 {}

			fragment = validation.ValidatorFragment2 {
				composedCheck = "org.eclipse.xtext.validation.NamesAreUniqueValidator"
			}

			fragment = scoping.ImportNamespacesScopingFragment2 {
				ignoreCase = true
			}

			fragment = exporting.QualifiedNamesFragment2 {}

			fragment = builder.BuilderIntegrationFragment2 {}

			//fragment = generator.GeneratorFragment2 {}

			fragment = formatting.Formatter2Fragment2 {
				generateXtendStub = true
			}

			fragment = ui.labeling.LabelProviderFragment2 {}

			fragment = ui.outline.QuickOutlineFragment2 {}

			fragment = ui.outline.OutlineTreeProviderFragment2 {}

			fragment = ui.quickfix.QuickfixProviderFragment2 {}

			fragment = ui.contentAssist.ContentAssistFragment2 {}

			//fragment = junit.JunitFragment {}

			fragment = ui.refactoring.RefactorElementNameFragment2 {}

			//fragment = types.TypesGeneratorFragment2 {}
			//fragment = xbase.XtypeGeneratorFragment2 {}
			//fragment = xbase.XbaseGeneratorFragment2 {}

			fragment = ui.templates.CodetemplatesGeneratorFragment2 {}

			fragment = ui.compare.CompareFragment2 {}

			//fragment = ui.projectWizard.TemplateProjectWizardFragment {}
			//fragment = ui.fileWizard.TemplateFileWizardFragment {}
		}
	}

//	component = Generator {
//		pathRtProject = runtimeProject
//		pathUiProject = "${runtimeProject}.ui"
//		projectNameRt = projectName
//		projectNameUi = "${projectName}.ui"
//		fileHeader = agreeFileHeader
//		language = {
//			uri = grammarURI
//			fileExtensions = file.extensions
//
//			// Java API to access grammar elements (required by several other fragments)
//			fragment = grammarAccess.GrammarAccessFragment {}
//
//			// generates Java API for the generated EPackages 
//			fragment = ecore.EMFGeneratorFragment {
//			}
//
////			// the serialization component
////			fragment = parseTreeConstructor.ParseTreeConstructorFragment {}
//            // Serializer 2.0
//            fragment = serializer.SerializerFragment {}
//
//			// a custom ResourceFactory for use with EMF 
//			fragment = resourceFactory.ResourceFactoryFragment {
//				fileExtensions = file.extensions
//			}
//
//			// The antlr parser generator fragment.
////			fragment = parser.antlr.XtextAntlrGeneratorFragment {
////			//  options = {
////			//		backtrack = true
////			//	}
////			}
//			fragment = parser.antlr.ex.rt.AntlrGeneratorFragment {
//    		options = {
//        		ignoreCase = true
////				backtrack = true
//				classSplitting = true
//    			}
//			}
//			
//			// java-based API for validation 
//			fragment = validation.JavaValidatorFragment {
////				composedCheck = "org.eclipse.xtext.validation.ImportUriValidator"
////				composedCheck = "org.eclipse.xtext.validation.NamesAreUniqueValidator"
//				// registerForImportedPackages = true
//			}
//
//			// scoping and exporting API
//			// fragment = scoping.ImportURIScopingFragment {}
////			 fragment = exporting.SimpleNamesFragment {}
//
//			// scoping and exporting API 
//			fragment = scoping.ImportNamespacesScopingFragment {}
//			fragment = exporting.QualifiedNamesFragment {}
//			fragment = builder.BuilderIntegrationFragment {}
//
////			// generator API
////			fragment = generator.GeneratorFragment {
////				generateMwe = true
////				generateJavaMain = true
////			}
//			
//			// formatter API 
////			fragment = formatting.FormatterFragment {}
//			fragment = formatting2.Formatter2Fragment auto-inject {}
//
//			// labeling API 
//			fragment = labeling.LabelProviderFragment {}
//
//			// outline API 
//			fragment = outline.OutlineTreeProviderFragment {}
//			fragment = outline.QuickOutlineFragment {}
//
//			// quickfix API 
//			fragment = quickfix.QuickfixProviderFragment {}
//
//			// content assist API  
//			fragment = contentAssist.JavaBasedContentAssistFragment {}
//			
//			// rename refactoring  
//			fragment = refactoring.RefactorElementNameFragment {}
//
//			// generates a more lightweight Antlr parser and lexer tailored for content assist  
////			fragment = parser.antlr.XtextAntlrUiGeneratorFragment {}
//			fragment = parser.antlr.ex.ca.ContentAssistParserGeneratorFragment {
//				options = {
//        			ignoreCase = true
////        			backtrack=true
//					classSplitting = true
//				}
//				partialParsing = true
//			}
//
//			// generates junit test support classes into Generator#pathTestProject
////			fragment = junit.Junit4Fragment {}
//
//			// project wizard (optional) 
//			// fragment = projectWizard.SimpleProjectWizardFragment {
//			// 		generatorProjectName = "${projectName}.generator" 
//			//		modelFileExtension = file.extensions
//			// }
//			
//			//fragment = types.TypesGeneratorFragment {}
//			// generates the required bindings only if the grammar inherits from Xbase
//			//fragment = xbase.XbaseGeneratorFragment {}
//		}
//	}

}

