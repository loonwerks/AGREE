/*
 * generated by Xtext 2.11.0
 */
package edu.uah.rsesc.aadlsimulator.xtext.serializer;

import com.google.inject.Inject;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.BinaryExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.BooleanLiteral;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.ConstRefExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.ElementRefExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.InputConstraintPackage;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.IntegerLiteral;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.IntervalExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.NegativeExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.PreExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.RandomElementExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.RandomIntegerExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.RandomRealExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.RealLiteral;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.SetExpression;
import edu.uah.rsesc.aadlsimulator.xtext.services.InputConstraintGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class InputConstraintSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private InputConstraintGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == InputConstraintPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case InputConstraintPackage.BINARY_EXPRESSION:
				sequence_AddSub_MultDiv(context, (BinaryExpression) semanticObject); 
				return; 
			case InputConstraintPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case InputConstraintPackage.CONST_REF_EXPRESSION:
				sequence_ConstRef(context, (ConstRefExpression) semanticObject); 
				return; 
			case InputConstraintPackage.ELEMENT_REF_EXPRESSION:
				sequence_ElementRef(context, (ElementRefExpression) semanticObject); 
				return; 
			case InputConstraintPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case InputConstraintPackage.INTERVAL_EXPRESSION:
				sequence_Interval(context, (IntervalExpression) semanticObject); 
				return; 
			case InputConstraintPackage.NEGATIVE_EXPRESSION:
				sequence_Negative(context, (NegativeExpression) semanticObject); 
				return; 
			case InputConstraintPackage.PRE_EXPRESSION:
				sequence_Pre(context, (PreExpression) semanticObject); 
				return; 
			case InputConstraintPackage.RANDOM_ELEMENT_EXPRESSION:
				sequence_RandomElement(context, (RandomElementExpression) semanticObject); 
				return; 
			case InputConstraintPackage.RANDOM_INTEGER_EXPRESSION:
				sequence_RandomInteger(context, (RandomIntegerExpression) semanticObject); 
				return; 
			case InputConstraintPackage.RANDOM_REAL_EXPRESSION:
				sequence_RandomReal(context, (RandomRealExpression) semanticObject); 
				return; 
			case InputConstraintPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case InputConstraintPackage.SET_EXPRESSION:
				sequence_Set(context, (SetExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     InputConstraint returns BinaryExpression
	 *     Expr returns BinaryExpression
	 *     Scalar returns BinaryExpression
	 *     AddSub returns BinaryExpression
	 *     AddSub.BinaryExpression_1_0 returns BinaryExpression
	 *     MultDiv returns BinaryExpression
	 *     MultDiv.BinaryExpression_1_0 returns BinaryExpression
	 *     Function returns BinaryExpression
	 *     Primary returns BinaryExpression
	 *
	 * Constraint:
	 *     ((left=AddSub_BinaryExpression_1_0 op=AddSubOperator right=MultDiv) | (left=MultDiv_BinaryExpression_1_0 op=MultDivOperator right=Function))
	 */
	protected void sequence_AddSub_MultDiv(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputConstraint returns BooleanLiteral
	 *     Expr returns BooleanLiteral
	 *     Scalar returns BooleanLiteral
	 *     AddSub returns BooleanLiteral
	 *     AddSub.BinaryExpression_1_0 returns BooleanLiteral
	 *     MultDiv returns BooleanLiteral
	 *     MultDiv.BinaryExpression_1_0 returns BooleanLiteral
	 *     Function returns BooleanLiteral
	 *     Primary returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value=TRUE | value=FALSE)
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputConstraint returns ConstRefExpression
	 *     Expr returns ConstRefExpression
	 *     Scalar returns ConstRefExpression
	 *     AddSub returns ConstRefExpression
	 *     AddSub.BinaryExpression_1_0 returns ConstRefExpression
	 *     MultDiv returns ConstRefExpression
	 *     MultDiv.BinaryExpression_1_0 returns ConstRefExpression
	 *     Function returns ConstRefExpression
	 *     Ref returns ConstRefExpression
	 *     ConstRef returns ConstRefExpression
	 *     Primary returns ConstRefExpression
	 *
	 * Constraint:
	 *     (packageSegments+=ID+ constantName=ID)
	 */
	protected void sequence_ConstRef(ISerializationContext context, ConstRefExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputConstraint returns ElementRefExpression
	 *     Expr returns ElementRefExpression
	 *     Scalar returns ElementRefExpression
	 *     AddSub returns ElementRefExpression
	 *     AddSub.BinaryExpression_1_0 returns ElementRefExpression
	 *     MultDiv returns ElementRefExpression
	 *     MultDiv.BinaryExpression_1_0 returns ElementRefExpression
	 *     Function returns ElementRefExpression
	 *     Ref returns ElementRefExpression
	 *     ElementRef returns ElementRefExpression
	 *     Primary returns ElementRefExpression
	 *
	 * Constraint:
	 *     (ids+=ID ids+=ID*)
	 */
	protected void sequence_ElementRef(ISerializationContext context, ElementRefExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputConstraint returns IntegerLiteral
	 *     Expr returns IntegerLiteral
	 *     Scalar returns IntegerLiteral
	 *     AddSub returns IntegerLiteral
	 *     AddSub.BinaryExpression_1_0 returns IntegerLiteral
	 *     MultDiv returns IntegerLiteral
	 *     MultDiv.BinaryExpression_1_0 returns IntegerLiteral
	 *     Function returns IntegerLiteral
	 *     Primary returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=BIG_INT
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerLiteralAccess().getValueBIG_INTParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputConstraint returns IntervalExpression
	 *     Expr returns IntervalExpression
	 *     Interval returns IntervalExpression
	 *
	 * Constraint:
	 *     (leftClosed?='['? left=Scalar? right=Scalar? rightClosed?=']'?)
	 */
	protected void sequence_Interval(ISerializationContext context, IntervalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputConstraint returns NegativeExpression
	 *     Expr returns NegativeExpression
	 *     Scalar returns NegativeExpression
	 *     AddSub returns NegativeExpression
	 *     AddSub.BinaryExpression_1_0 returns NegativeExpression
	 *     MultDiv returns NegativeExpression
	 *     MultDiv.BinaryExpression_1_0 returns NegativeExpression
	 *     Function returns NegativeExpression
	 *     Negative returns NegativeExpression
	 *     Primary returns NegativeExpression
	 *
	 * Constraint:
	 *     value=Scalar
	 */
	protected void sequence_Negative(ISerializationContext context, NegativeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.NEGATIVE_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.NEGATIVE_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegativeAccess().getValueScalarParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputConstraint returns PreExpression
	 *     Expr returns PreExpression
	 *     Scalar returns PreExpression
	 *     AddSub returns PreExpression
	 *     AddSub.BinaryExpression_1_0 returns PreExpression
	 *     MultDiv returns PreExpression
	 *     MultDiv.BinaryExpression_1_0 returns PreExpression
	 *     Function returns PreExpression
	 *     Pre returns PreExpression
	 *     Primary returns PreExpression
	 *
	 * Constraint:
	 *     ref=ElementRef?
	 */
	protected void sequence_Pre(ISerializationContext context, PreExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputConstraint returns RandomElementExpression
	 *     Expr returns RandomElementExpression
	 *     Scalar returns RandomElementExpression
	 *     AddSub returns RandomElementExpression
	 *     AddSub.BinaryExpression_1_0 returns RandomElementExpression
	 *     MultDiv returns RandomElementExpression
	 *     MultDiv.BinaryExpression_1_0 returns RandomElementExpression
	 *     Function returns RandomElementExpression
	 *     Random returns RandomElementExpression
	 *     RandomElement returns RandomElementExpression
	 *     Primary returns RandomElementExpression
	 *
	 * Constraint:
	 *     set=Set
	 */
	protected void sequence_RandomElement(ISerializationContext context, RandomElementExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.RANDOM_ELEMENT_EXPRESSION__SET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.RANDOM_ELEMENT_EXPRESSION__SET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRandomElementAccess().getSetSetParserRuleCall_1_0(), semanticObject.getSet());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputConstraint returns RandomIntegerExpression
	 *     Expr returns RandomIntegerExpression
	 *     Scalar returns RandomIntegerExpression
	 *     AddSub returns RandomIntegerExpression
	 *     AddSub.BinaryExpression_1_0 returns RandomIntegerExpression
	 *     MultDiv returns RandomIntegerExpression
	 *     MultDiv.BinaryExpression_1_0 returns RandomIntegerExpression
	 *     Function returns RandomIntegerExpression
	 *     Random returns RandomIntegerExpression
	 *     RandomInteger returns RandomIntegerExpression
	 *     Primary returns RandomIntegerExpression
	 *
	 * Constraint:
	 *     interval=Interval
	 */
	protected void sequence_RandomInteger(ISerializationContext context, RandomIntegerExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.RANDOM_INTEGER_EXPRESSION__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.RANDOM_INTEGER_EXPRESSION__INTERVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRandomIntegerAccess().getIntervalIntervalParserRuleCall_1_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputConstraint returns RandomRealExpression
	 *     Expr returns RandomRealExpression
	 *     Scalar returns RandomRealExpression
	 *     AddSub returns RandomRealExpression
	 *     AddSub.BinaryExpression_1_0 returns RandomRealExpression
	 *     MultDiv returns RandomRealExpression
	 *     MultDiv.BinaryExpression_1_0 returns RandomRealExpression
	 *     Function returns RandomRealExpression
	 *     Random returns RandomRealExpression
	 *     RandomReal returns RandomRealExpression
	 *     Primary returns RandomRealExpression
	 *
	 * Constraint:
	 *     interval=Interval
	 */
	protected void sequence_RandomReal(ISerializationContext context, RandomRealExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.RANDOM_REAL_EXPRESSION__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.RANDOM_REAL_EXPRESSION__INTERVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRandomRealAccess().getIntervalIntervalParserRuleCall_1_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputConstraint returns RealLiteral
	 *     Expr returns RealLiteral
	 *     Scalar returns RealLiteral
	 *     AddSub returns RealLiteral
	 *     AddSub.BinaryExpression_1_0 returns RealLiteral
	 *     MultDiv returns RealLiteral
	 *     MultDiv.BinaryExpression_1_0 returns RealLiteral
	 *     Function returns RealLiteral
	 *     Primary returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     value=BIGDECIMAL
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, InputConstraintPackage.Literals.REAL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, InputConstraintPackage.Literals.REAL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralAccess().getValueBIGDECIMALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputConstraint returns SetExpression
	 *     Expr returns SetExpression
	 *     Set returns SetExpression
	 *
	 * Constraint:
	 *     (members+=Scalar members+=Scalar*)?
	 */
	protected void sequence_Set(ISerializationContext context, SetExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
