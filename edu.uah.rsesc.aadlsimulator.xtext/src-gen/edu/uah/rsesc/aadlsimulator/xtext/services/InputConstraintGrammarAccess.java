/*
 * generated by Xtext 2.11.0
 */
package edu.uah.rsesc.aadlsimulator.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class InputConstraintGrammarAccess extends AbstractGrammarElementFinder {
	
	public class InputConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.InputConstraint");
		private final RuleCall cExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//InputConstraint:
		//	Expr;
		@Override public ParserRule getRule() { return rule; }
		
		//Expr
		public RuleCall getExprParserRuleCall() { return cExprParserRuleCall; }
	}
	public class ExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.Expr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cScalarParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIntervalParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSetParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Expr Expression:
		//	Scalar | Interval | Set;
		@Override public ParserRule getRule() { return rule; }
		
		//Scalar | Interval | Set
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Scalar
		public RuleCall getScalarParserRuleCall_0() { return cScalarParserRuleCall_0; }
		
		//Interval
		public RuleCall getIntervalParserRuleCall_1() { return cIntervalParserRuleCall_1; }
		
		//Set
		public RuleCall getSetParserRuleCall_2() { return cSetParserRuleCall_2; }
	}
	public class ScalarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.Scalar");
		private final RuleCall cAddSubParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Scalar ScalarExpression:
		//	AddSub;
		@Override public ParserRule getRule() { return rule; }
		
		//AddSub
		public RuleCall getAddSubParserRuleCall() { return cAddSubParserRuleCall; }
	}
	public class AddSubElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.AddSub");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultDivParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpAddSubOperatorEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultDivParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AddSub ScalarExpression:
		//	MultDiv ({BinaryExpression.left=current} op=AddSubOperator right=MultDiv)*;
		@Override public ParserRule getRule() { return rule; }
		
		//MultDiv ({BinaryExpression.left=current} op=AddSubOperator right=MultDiv)*
		public Group getGroup() { return cGroup; }
		
		//MultDiv
		public RuleCall getMultDivParserRuleCall_0() { return cMultDivParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=AddSubOperator right=MultDiv)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=AddSubOperator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//AddSubOperator
		public RuleCall getOpAddSubOperatorEnumRuleCall_1_1_0() { return cOpAddSubOperatorEnumRuleCall_1_1_0; }
		
		//right=MultDiv
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//MultDiv
		public RuleCall getRightMultDivParserRuleCall_1_2_0() { return cRightMultDivParserRuleCall_1_2_0; }
	}
	public class MultDivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.MultDiv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFunctionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpMultDivOperatorEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightFunctionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//MultDiv ScalarExpression:
		//	Function ({BinaryExpression.left=current} op=MultDivOperator right=Function)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Function ({BinaryExpression.left=current} op=MultDivOperator right=Function)*
		public Group getGroup() { return cGroup; }
		
		//Function
		public RuleCall getFunctionParserRuleCall_0() { return cFunctionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=MultDivOperator right=Function)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=MultDivOperator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//MultDivOperator
		public RuleCall getOpMultDivOperatorEnumRuleCall_1_1_0() { return cOpMultDivOperatorEnumRuleCall_1_1_0; }
		
		//right=Function
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Function
		public RuleCall getRightFunctionParserRuleCall_1_2_0() { return cRightFunctionParserRuleCall_1_2_0; }
	}
	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.Function");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPreParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRandomParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRefParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConstRefParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cNegativeParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cPrimaryParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//Function ScalarExpression:
		//	Pre | Random | Ref | ConstRef | Negative | Primary;
		@Override public ParserRule getRule() { return rule; }
		
		//Pre | Random | Ref | ConstRef | Negative | Primary
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Pre
		public RuleCall getPreParserRuleCall_0() { return cPreParserRuleCall_0; }
		
		//Random
		public RuleCall getRandomParserRuleCall_1() { return cRandomParserRuleCall_1; }
		
		//Ref
		public RuleCall getRefParserRuleCall_2() { return cRefParserRuleCall_2; }
		
		//ConstRef
		public RuleCall getConstRefParserRuleCall_3() { return cConstRefParserRuleCall_3; }
		
		//Negative
		public RuleCall getNegativeParserRuleCall_4() { return cNegativeParserRuleCall_4; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_5() { return cPrimaryParserRuleCall_5; }
	}
	public class PreElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.Pre");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPreExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPreKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRefAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRefElementRefParserRuleCall_3_0 = (RuleCall)cRefAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Pre ScalarExpression:
		//	{PreExpression} 'pre' '(' ref=ElementRef? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{PreExpression} 'pre' '(' ref=ElementRef? ')'
		public Group getGroup() { return cGroup; }
		
		//{PreExpression}
		public Action getPreExpressionAction_0() { return cPreExpressionAction_0; }
		
		//'pre'
		public Keyword getPreKeyword_1() { return cPreKeyword_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//ref=ElementRef?
		public Assignment getRefAssignment_3() { return cRefAssignment_3; }
		
		//ElementRef
		public RuleCall getRefElementRefParserRuleCall_3_0() { return cRefElementRefParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class RandomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.Random");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRandomIntegerParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRandomRealParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRandomElementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Random RandomExpression:
		//	RandomInteger | RandomReal | RandomElement;
		@Override public ParserRule getRule() { return rule; }
		
		//RandomInteger | RandomReal | RandomElement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//RandomInteger
		public RuleCall getRandomIntegerParserRuleCall_0() { return cRandomIntegerParserRuleCall_0; }
		
		//RandomReal
		public RuleCall getRandomRealParserRuleCall_1() { return cRandomRealParserRuleCall_1; }
		
		//RandomElement
		public RuleCall getRandomElementParserRuleCall_2() { return cRandomElementParserRuleCall_2; }
	}
	public class RandomIntegerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.RandomInteger");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRandomIntegerExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cIntervalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIntervalIntervalParserRuleCall_1_0 = (RuleCall)cIntervalAssignment_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRand_intKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//RandomInteger RandomExpression:
		//	{RandomIntegerExpression} interval=Interval '.' 'rand_int()';
		@Override public ParserRule getRule() { return rule; }
		
		//{RandomIntegerExpression} interval=Interval '.' 'rand_int()'
		public Group getGroup() { return cGroup; }
		
		//{RandomIntegerExpression}
		public Action getRandomIntegerExpressionAction_0() { return cRandomIntegerExpressionAction_0; }
		
		//interval=Interval
		public Assignment getIntervalAssignment_1() { return cIntervalAssignment_1; }
		
		//Interval
		public RuleCall getIntervalIntervalParserRuleCall_1_0() { return cIntervalIntervalParserRuleCall_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
		
		//'rand_int()'
		public Keyword getRand_intKeyword_3() { return cRand_intKeyword_3; }
	}
	public class RandomRealElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.RandomReal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRandomRealExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cIntervalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIntervalIntervalParserRuleCall_1_0 = (RuleCall)cIntervalAssignment_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRand_realKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//RandomReal RandomExpression:
		//	{RandomRealExpression} interval=Interval '.' 'rand_real()';
		@Override public ParserRule getRule() { return rule; }
		
		//{RandomRealExpression} interval=Interval '.' 'rand_real()'
		public Group getGroup() { return cGroup; }
		
		//{RandomRealExpression}
		public Action getRandomRealExpressionAction_0() { return cRandomRealExpressionAction_0; }
		
		//interval=Interval
		public Assignment getIntervalAssignment_1() { return cIntervalAssignment_1; }
		
		//Interval
		public RuleCall getIntervalIntervalParserRuleCall_1_0() { return cIntervalIntervalParserRuleCall_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
		
		//'rand_real()'
		public Keyword getRand_realKeyword_3() { return cRand_realKeyword_3; }
	}
	public class RandomElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.RandomElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRandomElementExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cSetAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSetSetParserRuleCall_1_0 = (RuleCall)cSetAssignment_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRandKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//RandomElement RandomExpression:
		//	{RandomElementExpression} set=Set '.' 'rand()';
		@Override public ParserRule getRule() { return rule; }
		
		//{RandomElementExpression} set=Set '.' 'rand()'
		public Group getGroup() { return cGroup; }
		
		//{RandomElementExpression}
		public Action getRandomElementExpressionAction_0() { return cRandomElementExpressionAction_0; }
		
		//set=Set
		public Assignment getSetAssignment_1() { return cSetAssignment_1; }
		
		//Set
		public RuleCall getSetSetParserRuleCall_1_0() { return cSetSetParserRuleCall_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
		
		//'rand()'
		public Keyword getRandKeyword_3() { return cRandKeyword_3; }
	}
	public class RefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.Ref");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cElementRefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Ref RefExpression:
		//	ElementRef | ConstRef;
		@Override public ParserRule getRule() { return rule; }
		
		//ElementRef | ConstRef
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ElementRef
		public RuleCall getElementRefParserRuleCall_0() { return cElementRefParserRuleCall_0; }
		
		//ConstRef
		public RuleCall getConstRefParserRuleCall_1() { return cConstRefParserRuleCall_1; }
	}
	public class ElementRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.ElementRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cElementRefExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cIdsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdsIDTerminalRuleCall_1_0 = (RuleCall)cIdsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cIdsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cIdsIDTerminalRuleCall_2_1_0 = (RuleCall)cIdsAssignment_2_1.eContents().get(0);
		
		//ElementRef ElementRefExpression:
		//	{ElementRefExpression} ids+=ID ('.' ids+=ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//{ElementRefExpression} ids+=ID ('.' ids+=ID)*
		public Group getGroup() { return cGroup; }
		
		//{ElementRefExpression}
		public Action getElementRefExpressionAction_0() { return cElementRefExpressionAction_0; }
		
		//ids+=ID
		public Assignment getIdsAssignment_1() { return cIdsAssignment_1; }
		
		//ID
		public RuleCall getIdsIDTerminalRuleCall_1_0() { return cIdsIDTerminalRuleCall_1_0; }
		
		//('.' ids+=ID)*
		public Group getGroup_2() { return cGroup_2; }
		
		//'.'
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }
		
		//ids+=ID
		public Assignment getIdsAssignment_2_1() { return cIdsAssignment_2_1; }
		
		//ID
		public RuleCall getIdsIDTerminalRuleCall_2_1_0() { return cIdsIDTerminalRuleCall_2_1_0; }
	}
	public class ConstRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.ConstRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConstRefExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cPackageSegmentsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cPackageSegmentsIDTerminalRuleCall_1_0_0 = (RuleCall)cPackageSegmentsAssignment_1_0.eContents().get(0);
		private final Keyword cColonColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cConstantNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConstantNameIDTerminalRuleCall_2_0 = (RuleCall)cConstantNameAssignment_2.eContents().get(0);
		
		//ConstRef RefExpression:
		//	{ConstRefExpression} (packageSegments+=ID '::')+ constantName=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//{ConstRefExpression} (packageSegments+=ID '::')+ constantName=ID
		public Group getGroup() { return cGroup; }
		
		//{ConstRefExpression}
		public Action getConstRefExpressionAction_0() { return cConstRefExpressionAction_0; }
		
		//(packageSegments+=ID '::')+
		public Group getGroup_1() { return cGroup_1; }
		
		//packageSegments+=ID
		public Assignment getPackageSegmentsAssignment_1_0() { return cPackageSegmentsAssignment_1_0; }
		
		//ID
		public RuleCall getPackageSegmentsIDTerminalRuleCall_1_0_0() { return cPackageSegmentsIDTerminalRuleCall_1_0_0; }
		
		//'::'
		public Keyword getColonColonKeyword_1_1() { return cColonColonKeyword_1_1; }
		
		//constantName=ID
		public Assignment getConstantNameAssignment_2() { return cConstantNameAssignment_2; }
		
		//ID
		public RuleCall getConstantNameIDTerminalRuleCall_2_0() { return cConstantNameIDTerminalRuleCall_2_0; }
	}
	public class NegativeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.Negative");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNegativeExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueScalarParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Negative ScalarExpression:
		//	{NegativeExpression} '-' value=Scalar;
		@Override public ParserRule getRule() { return rule; }
		
		//{NegativeExpression} '-' value=Scalar
		public Group getGroup() { return cGroup; }
		
		//{NegativeExpression}
		public Action getNegativeExpressionAction_0() { return cNegativeExpressionAction_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
		
		//value=Scalar
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Scalar
		public RuleCall getValueScalarParserRuleCall_2_0() { return cValueScalarParserRuleCall_2_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntegerLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRealLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cScalarParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		
		//Primary ScalarExpression:
		//	IntegerLiteral | RealLiteral | BooleanLiteral |
		//	'(' Scalar ')';
		@Override public ParserRule getRule() { return rule; }
		
		//IntegerLiteral | RealLiteral | BooleanLiteral | '(' Scalar ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IntegerLiteral
		public RuleCall getIntegerLiteralParserRuleCall_0() { return cIntegerLiteralParserRuleCall_0; }
		
		//RealLiteral
		public RuleCall getRealLiteralParserRuleCall_1() { return cRealLiteralParserRuleCall_1; }
		
		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_2() { return cBooleanLiteralParserRuleCall_2; }
		
		//'(' Scalar ')'
		public Group getGroup_3() { return cGroup_3; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }
		
		//Scalar
		public RuleCall getScalarParserRuleCall_3_1() { return cScalarParserRuleCall_3_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }
	}
	public class IntervalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.Interval");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIntervalExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cLeftClosedAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final Keyword cLeftClosedLeftSquareBracketKeyword_1_0_0 = (Keyword)cLeftClosedAssignment_1_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftScalarParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightScalarParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Assignment cRightClosedAssignment_5_0 = (Assignment)cAlternatives_5.eContents().get(0);
		private final Keyword cRightClosedRightSquareBracketKeyword_5_0_0 = (Keyword)cRightClosedAssignment_5_0.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5_1 = (Keyword)cAlternatives_5.eContents().get(1);
		
		//// Unbounded expressions are represented with an empty left or right
		//Interval IntervalExpression:
		//	{IntervalExpression} (leftClosed?='[' | '(') left=Scalar? ',' right=Scalar? (rightClosed?=']' | ')');
		@Override public ParserRule getRule() { return rule; }
		
		//{IntervalExpression} (leftClosed?='[' | '(') left=Scalar? ',' right=Scalar? (rightClosed?=']' | ')')
		public Group getGroup() { return cGroup; }
		
		//{IntervalExpression}
		public Action getIntervalExpressionAction_0() { return cIntervalExpressionAction_0; }
		
		//leftClosed?='[' | '('
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//leftClosed?='['
		public Assignment getLeftClosedAssignment_1_0() { return cLeftClosedAssignment_1_0; }
		
		//'['
		public Keyword getLeftClosedLeftSquareBracketKeyword_1_0_0() { return cLeftClosedLeftSquareBracketKeyword_1_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }
		
		//left=Scalar?
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Scalar
		public RuleCall getLeftScalarParserRuleCall_2_0() { return cLeftScalarParserRuleCall_2_0; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//right=Scalar?
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Scalar
		public RuleCall getRightScalarParserRuleCall_4_0() { return cRightScalarParserRuleCall_4_0; }
		
		//rightClosed?=']' | ')'
		public Alternatives getAlternatives_5() { return cAlternatives_5; }
		
		//rightClosed?=']'
		public Assignment getRightClosedAssignment_5_0() { return cRightClosedAssignment_5_0; }
		
		//']'
		public Keyword getRightClosedRightSquareBracketKeyword_5_0_0() { return cRightClosedRightSquareBracketKeyword_5_0_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5_1() { return cRightParenthesisKeyword_5_1; }
	}
	public class SetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.Set");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSetExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cMembersAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cMembersScalarParserRuleCall_2_0_0 = (RuleCall)cMembersAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cMembersAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cMembersScalarParserRuleCall_2_1_1_0 = (RuleCall)cMembersAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Set SetExpression:
		//	{SetExpression} '{' (members+=Scalar (',' members+=Scalar)*)? '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{SetExpression} '{' (members+=Scalar (',' members+=Scalar)*)? '}'
		public Group getGroup() { return cGroup; }
		
		//{SetExpression}
		public Action getSetExpressionAction_0() { return cSetExpressionAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//(members+=Scalar (',' members+=Scalar)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//members+=Scalar
		public Assignment getMembersAssignment_2_0() { return cMembersAssignment_2_0; }
		
		//Scalar
		public RuleCall getMembersScalarParserRuleCall_2_0_0() { return cMembersScalarParserRuleCall_2_0_0; }
		
		//(',' members+=Scalar)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//members+=Scalar
		public Assignment getMembersAssignment_2_1_1() { return cMembersAssignment_2_1_1; }
		
		//Scalar
		public RuleCall getMembersScalarParserRuleCall_2_1_1_0() { return cMembersScalarParserRuleCall_2_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class IntegerLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.IntegerLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBIG_INTParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntegerLiteral:
		//	value=BIG_INT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=BIG_INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//BIG_INT
		public RuleCall getValueBIG_INTParserRuleCall_0() { return cValueBIG_INTParserRuleCall_0; }
	}
	public class RealLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.RealLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBIGDECIMALTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//RealLiteral:
		//	value=BIGDECIMAL;
		@Override public ParserRule getRule() { return rule; }
		
		//value=BIGDECIMAL
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//BIGDECIMAL
		public RuleCall getValueBIGDECIMALTerminalRuleCall_0() { return cValueBIGDECIMALTerminalRuleCall_0; }
	}
	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.BooleanLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cValueTRUETerminalRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cValueFALSETerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//BooleanLiteral:
		//	value=TRUE | value=FALSE;
		@Override public ParserRule getRule() { return rule; }
		
		//value=TRUE | value=FALSE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//value=TRUE
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//TRUE
		public RuleCall getValueTRUETerminalRuleCall_0_0() { return cValueTRUETerminalRuleCall_0_0; }
		
		//value=FALSE
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//FALSE
		public RuleCall getValueFALSETerminalRuleCall_1_0() { return cValueFALSETerminalRuleCall_1_0; }
	}
	public class BIG_INTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.BIG_INT");
		private final RuleCall cINTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//BIG_INT ecore::EBigInteger:
		//	INT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT
		public RuleCall getINTTerminalRuleCall() { return cINTTerminalRuleCall; }
	}
	
	public class OperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.Operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAddSubOperatorEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAddSubOperatorAddSubOperatorKeyword_0_0 = (Keyword)cAddSubOperatorEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMultiDivOperatorEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMultiDivOperatorMultiDivOperatorKeyword_1_0 = (Keyword)cMultiDivOperatorEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Operator:
		//	AddSubOperator | MultiDivOperator;
		public EnumRule getRule() { return rule; }
		
		//AddSubOperator | MultiDivOperator
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AddSubOperator
		public EnumLiteralDeclaration getAddSubOperatorEnumLiteralDeclaration_0() { return cAddSubOperatorEnumLiteralDeclaration_0; }
		
		//"AddSubOperator"
		public Keyword getAddSubOperatorAddSubOperatorKeyword_0_0() { return cAddSubOperatorAddSubOperatorKeyword_0_0; }
		
		//MultiDivOperator
		public EnumLiteralDeclaration getMultiDivOperatorEnumLiteralDeclaration_1() { return cMultiDivOperatorEnumLiteralDeclaration_1; }
		
		//"MultiDivOperator"
		public Keyword getMultiDivOperatorMultiDivOperatorKeyword_1_0() { return cMultiDivOperatorMultiDivOperatorKeyword_1_0; }
	}
	public class AddSubOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.AddSubOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cADDITIONEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cADDITIONPlusSignKeyword_0_0 = (Keyword)cADDITIONEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSUBTRACTIONEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSUBTRACTIONHyphenMinusKeyword_1_0 = (Keyword)cSUBTRACTIONEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AddSubOperator returns Operator:
		//	ADDITION='+' | SUBTRACTION='-';
		public EnumRule getRule() { return rule; }
		
		//ADDITION='+' | SUBTRACTION='-'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ADDITION='+'
		public EnumLiteralDeclaration getADDITIONEnumLiteralDeclaration_0() { return cADDITIONEnumLiteralDeclaration_0; }
		
		//'+'
		public Keyword getADDITIONPlusSignKeyword_0_0() { return cADDITIONPlusSignKeyword_0_0; }
		
		//SUBTRACTION='-'
		public EnumLiteralDeclaration getSUBTRACTIONEnumLiteralDeclaration_1() { return cSUBTRACTIONEnumLiteralDeclaration_1; }
		
		//'-'
		public Keyword getSUBTRACTIONHyphenMinusKeyword_1_0() { return cSUBTRACTIONHyphenMinusKeyword_1_0; }
	}
	public class MultDivOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.MultDivOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMULTIPLICATIONEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMULTIPLICATIONAsteriskKeyword_0_0 = (Keyword)cMULTIPLICATIONEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVISIONEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVISIONSolidusKeyword_1_0 = (Keyword)cDIVISIONEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MultDivOperator returns Operator:
		//	MULTIPLICATION='*' | DIVISION='/';
		public EnumRule getRule() { return rule; }
		
		//MULTIPLICATION='*' | DIVISION='/'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MULTIPLICATION='*'
		public EnumLiteralDeclaration getMULTIPLICATIONEnumLiteralDeclaration_0() { return cMULTIPLICATIONEnumLiteralDeclaration_0; }
		
		//'*'
		public Keyword getMULTIPLICATIONAsteriskKeyword_0_0() { return cMULTIPLICATIONAsteriskKeyword_0_0; }
		
		//DIVISION='/'
		public EnumLiteralDeclaration getDIVISIONEnumLiteralDeclaration_1() { return cDIVISIONEnumLiteralDeclaration_1; }
		
		//'/'
		public Keyword getDIVISIONSolidusKeyword_1_0() { return cDIVISIONSolidusKeyword_1_0; }
	}
	
	private final InputConstraintElements pInputConstraint;
	private final ExprElements pExpr;
	private final ScalarElements pScalar;
	private final OperatorElements eOperator;
	private final AddSubOperatorElements eAddSubOperator;
	private final MultDivOperatorElements eMultDivOperator;
	private final AddSubElements pAddSub;
	private final MultDivElements pMultDiv;
	private final FunctionElements pFunction;
	private final PreElements pPre;
	private final RandomElements pRandom;
	private final RandomIntegerElements pRandomInteger;
	private final RandomRealElements pRandomReal;
	private final RandomElementElements pRandomElement;
	private final RefElements pRef;
	private final ElementRefElements pElementRef;
	private final ConstRefElements pConstRef;
	private final NegativeElements pNegative;
	private final PrimaryElements pPrimary;
	private final IntervalElements pInterval;
	private final SetElements pSet;
	private final IntegerLiteralElements pIntegerLiteral;
	private final RealLiteralElements pRealLiteral;
	private final BooleanLiteralElements pBooleanLiteral;
	private final BIG_INTElements pBIG_INT;
	private final TerminalRule tBIGDECIMAL;
	private final TerminalRule tTRUE;
	private final TerminalRule tFALSE;
	private final TerminalRule tID;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public InputConstraintGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pInputConstraint = new InputConstraintElements();
		this.pExpr = new ExprElements();
		this.pScalar = new ScalarElements();
		this.eOperator = new OperatorElements();
		this.eAddSubOperator = new AddSubOperatorElements();
		this.eMultDivOperator = new MultDivOperatorElements();
		this.pAddSub = new AddSubElements();
		this.pMultDiv = new MultDivElements();
		this.pFunction = new FunctionElements();
		this.pPre = new PreElements();
		this.pRandom = new RandomElements();
		this.pRandomInteger = new RandomIntegerElements();
		this.pRandomReal = new RandomRealElements();
		this.pRandomElement = new RandomElementElements();
		this.pRef = new RefElements();
		this.pElementRef = new ElementRefElements();
		this.pConstRef = new ConstRefElements();
		this.pNegative = new NegativeElements();
		this.pPrimary = new PrimaryElements();
		this.pInterval = new IntervalElements();
		this.pSet = new SetElements();
		this.pIntegerLiteral = new IntegerLiteralElements();
		this.pRealLiteral = new RealLiteralElements();
		this.pBooleanLiteral = new BooleanLiteralElements();
		this.pBIG_INT = new BIG_INTElements();
		this.tBIGDECIMAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.BIGDECIMAL");
		this.tTRUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.TRUE");
		this.tFALSE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.FALSE");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.uah.rsesc.aadlsimulator.xtext.InputConstraint.ID");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("edu.uah.rsesc.aadlsimulator.xtext.InputConstraint".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//InputConstraint:
	//	Expr;
	public InputConstraintElements getInputConstraintAccess() {
		return pInputConstraint;
	}
	
	public ParserRule getInputConstraintRule() {
		return getInputConstraintAccess().getRule();
	}
	
	//Expr Expression:
	//	Scalar | Interval | Set;
	public ExprElements getExprAccess() {
		return pExpr;
	}
	
	public ParserRule getExprRule() {
		return getExprAccess().getRule();
	}
	
	//Scalar ScalarExpression:
	//	AddSub;
	public ScalarElements getScalarAccess() {
		return pScalar;
	}
	
	public ParserRule getScalarRule() {
		return getScalarAccess().getRule();
	}
	
	//enum Operator:
	//	AddSubOperator | MultiDivOperator;
	public OperatorElements getOperatorAccess() {
		return eOperator;
	}
	
	public EnumRule getOperatorRule() {
		return getOperatorAccess().getRule();
	}
	
	//enum AddSubOperator returns Operator:
	//	ADDITION='+' | SUBTRACTION='-';
	public AddSubOperatorElements getAddSubOperatorAccess() {
		return eAddSubOperator;
	}
	
	public EnumRule getAddSubOperatorRule() {
		return getAddSubOperatorAccess().getRule();
	}
	
	//enum MultDivOperator returns Operator:
	//	MULTIPLICATION='*' | DIVISION='/';
	public MultDivOperatorElements getMultDivOperatorAccess() {
		return eMultDivOperator;
	}
	
	public EnumRule getMultDivOperatorRule() {
		return getMultDivOperatorAccess().getRule();
	}
	
	//AddSub ScalarExpression:
	//	MultDiv ({BinaryExpression.left=current} op=AddSubOperator right=MultDiv)*;
	public AddSubElements getAddSubAccess() {
		return pAddSub;
	}
	
	public ParserRule getAddSubRule() {
		return getAddSubAccess().getRule();
	}
	
	//MultDiv ScalarExpression:
	//	Function ({BinaryExpression.left=current} op=MultDivOperator right=Function)*;
	public MultDivElements getMultDivAccess() {
		return pMultDiv;
	}
	
	public ParserRule getMultDivRule() {
		return getMultDivAccess().getRule();
	}
	
	//Function ScalarExpression:
	//	Pre | Random | Ref | ConstRef | Negative | Primary;
	public FunctionElements getFunctionAccess() {
		return pFunction;
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}
	
	//Pre ScalarExpression:
	//	{PreExpression} 'pre' '(' ref=ElementRef? ')';
	public PreElements getPreAccess() {
		return pPre;
	}
	
	public ParserRule getPreRule() {
		return getPreAccess().getRule();
	}
	
	//Random RandomExpression:
	//	RandomInteger | RandomReal | RandomElement;
	public RandomElements getRandomAccess() {
		return pRandom;
	}
	
	public ParserRule getRandomRule() {
		return getRandomAccess().getRule();
	}
	
	//RandomInteger RandomExpression:
	//	{RandomIntegerExpression} interval=Interval '.' 'rand_int()';
	public RandomIntegerElements getRandomIntegerAccess() {
		return pRandomInteger;
	}
	
	public ParserRule getRandomIntegerRule() {
		return getRandomIntegerAccess().getRule();
	}
	
	//RandomReal RandomExpression:
	//	{RandomRealExpression} interval=Interval '.' 'rand_real()';
	public RandomRealElements getRandomRealAccess() {
		return pRandomReal;
	}
	
	public ParserRule getRandomRealRule() {
		return getRandomRealAccess().getRule();
	}
	
	//RandomElement RandomExpression:
	//	{RandomElementExpression} set=Set '.' 'rand()';
	public RandomElementElements getRandomElementAccess() {
		return pRandomElement;
	}
	
	public ParserRule getRandomElementRule() {
		return getRandomElementAccess().getRule();
	}
	
	//Ref RefExpression:
	//	ElementRef | ConstRef;
	public RefElements getRefAccess() {
		return pRef;
	}
	
	public ParserRule getRefRule() {
		return getRefAccess().getRule();
	}
	
	//ElementRef ElementRefExpression:
	//	{ElementRefExpression} ids+=ID ('.' ids+=ID)*;
	public ElementRefElements getElementRefAccess() {
		return pElementRef;
	}
	
	public ParserRule getElementRefRule() {
		return getElementRefAccess().getRule();
	}
	
	//ConstRef RefExpression:
	//	{ConstRefExpression} (packageSegments+=ID '::')+ constantName=ID;
	public ConstRefElements getConstRefAccess() {
		return pConstRef;
	}
	
	public ParserRule getConstRefRule() {
		return getConstRefAccess().getRule();
	}
	
	//Negative ScalarExpression:
	//	{NegativeExpression} '-' value=Scalar;
	public NegativeElements getNegativeAccess() {
		return pNegative;
	}
	
	public ParserRule getNegativeRule() {
		return getNegativeAccess().getRule();
	}
	
	//Primary ScalarExpression:
	//	IntegerLiteral | RealLiteral | BooleanLiteral |
	//	'(' Scalar ')';
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//// Unbounded expressions are represented with an empty left or right
	//Interval IntervalExpression:
	//	{IntervalExpression} (leftClosed?='[' | '(') left=Scalar? ',' right=Scalar? (rightClosed?=']' | ')');
	public IntervalElements getIntervalAccess() {
		return pInterval;
	}
	
	public ParserRule getIntervalRule() {
		return getIntervalAccess().getRule();
	}
	
	//Set SetExpression:
	//	{SetExpression} '{' (members+=Scalar (',' members+=Scalar)*)? '}';
	public SetElements getSetAccess() {
		return pSet;
	}
	
	public ParserRule getSetRule() {
		return getSetAccess().getRule();
	}
	
	//IntegerLiteral:
	//	value=BIG_INT;
	public IntegerLiteralElements getIntegerLiteralAccess() {
		return pIntegerLiteral;
	}
	
	public ParserRule getIntegerLiteralRule() {
		return getIntegerLiteralAccess().getRule();
	}
	
	//RealLiteral:
	//	value=BIGDECIMAL;
	public RealLiteralElements getRealLiteralAccess() {
		return pRealLiteral;
	}
	
	public ParserRule getRealLiteralRule() {
		return getRealLiteralAccess().getRule();
	}
	
	//BooleanLiteral:
	//	value=TRUE | value=FALSE;
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return pBooleanLiteral;
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}
	
	//BIG_INT ecore::EBigInteger:
	//	INT;
	public BIG_INTElements getBIG_INTAccess() {
		return pBIG_INT;
	}
	
	public ParserRule getBIG_INTRule() {
		return getBIG_INTAccess().getRule();
	}
	
	//terminal BIGDECIMAL returns ecore::EBigDecimal:
	//	'0'..'9'* '.' '0'..'9'+;
	public TerminalRule getBIGDECIMALRule() {
		return tBIGDECIMAL;
	}
	
	//terminal TRUE returns ecore::EBoolean:
	//	'true';
	public TerminalRule getTRUERule() {
		return tTRUE;
	}
	
	//terminal FALSE returns ecore::EBoolean:
	//	'false';
	public TerminalRule getFALSERule() {
		return tFALSE;
	}
	
	//@ Override terminal ID:
	//	('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* ('[' '0'..'9'+ ']')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
