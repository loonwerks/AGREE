/*
 * generated by Xtext 2.11.0
 */
package edu.uah.rsesc.aadlsimulator.xtext.validation;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;

import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.BinaryExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.BooleanLiteral;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.ConstRefExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.ElementRefExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.InputConstraint;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.InputConstraintPackage;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.IntervalExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.NegativeExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.Operator;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.PreExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.RandomExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.RandomIntegerExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.RandomRealExpression;
import edu.uah.rsesc.aadlsimulator.xtext.inputConstraint.SetExpression;
import edu.uah.rsesc.aadlsimulator.xtext.util.InputConstraintTypeDeterminer;
import edu.uah.rsesc.aadlsimulator.xtext.util.ReferenceTypeResolver;
import edu.uah.rsesc.aadlsimulator.xtext.util.ResultType;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class InputConstraintValidator extends AbstractInputConstraintValidator {
	public static String CONTEXT_KEY_EXPECTED_TYPE = "edu.uah.rsesc.aadlsimulator.xtext.validation.expectedType";	
	public static String CONTEXT_KEY_NUMBER_OF_PREVIOUS_STEPS = "edu.uah.rsesc.aadlsimulator.xtext.validation.numberOfPreviousSteps";
	
	private InputConstraintTypeDeterminer typeDeterminer; // Should not be accessed directly. Use getTypeDeterminer()
	
	@Check
	public void checkNegativeNotContainedInNegative(final NegativeExpression negExpr) {
		if(negExpr.eContainer() instanceof NegativeExpression) {
			error("Multiple '-' operators are not allowed.", InputConstraintPackage.Literals.NEGATIVE_EXPRESSION__VALUE);
		}
	}
	
	@Check
	public void checkNegativeNotBoolean(final NegativeExpression negExpr) {
		if(negExpr.getValue() instanceof BooleanLiteral) {
			error("Negation of boolean values is not allowed.", InputConstraintPackage.Literals.NEGATIVE_EXPRESSION__VALUE);
		}
	}
	
	@Check
	public void checkIntervalNotUnbounded(final IntervalExpression intervalExpr) {
		if(intervalExpr.getLeft() == null && intervalExpr.getRight() == null) {
			error("Intervals must not be completely unbounded.", InputConstraintPackage.Literals.INTERVAL_EXPRESSION__LEFT);
		}
	}
	
	@Check
	public void checkReferences(final ElementRefExpression refExpr) {
		if(getTypeDeterminer().determineType(refExpr) == null) {
			error("Invalid reference", InputConstraintPackage.Literals.ELEMENT_REF_EXPRESSION__IDS);
		}
	}
	
	@Check
	public void checkReferences(final ConstRefExpression refExpr) {
		if(getTypeDeterminer().determineType(refExpr) == null) {
			error("Invalid reference", InputConstraintPackage.Literals.CONST_REF_EXPRESSION__CONSTANT_NAME);
		}
	}
	
	@Check
	public void checkIntervalTypes(final IntervalExpression intervalExpr) {
		if(intervalExpr != null && intervalExpr != null) {
			final InputConstraintTypeDeterminer typeDeterminer = getTypeDeterminer();
			final ResultType leftType = typeDeterminer.determineType(intervalExpr.getLeft());
			final ResultType rightType = typeDeterminer.determineType(intervalExpr.getRight());
			if(leftType != rightType) {
				error("Both sides of an interval must be of the same type. Left: " + leftType + ". Right: " + rightType + ".", InputConstraintPackage.Literals.INTERVAL_EXPRESSION__LEFT);
			}	
			
			if(!(leftType == null || leftType == ResultType.INTEGER || leftType == ResultType.REAL)) {
				error("Interval bounds must be of type integer or real. Type: " + leftType + ".", InputConstraintPackage.Literals.INTERVAL_EXPRESSION__LEFT);
			}
		}
	}
	
	@Check
	public void checkSetNotEmpty(final SetExpression setExpr) {
		if(setExpr.getMembers().size() <= 0) {
			error("Sets must not be empty.", InputConstraintPackage.Literals.SET_EXPRESSION__MEMBERS);
		}
	}
	
	@Check
	public void checkSetMemberTypes(final SetExpression setExpr) {
		// Check that all the members of the set are of the same type.
		final InputConstraintTypeDeterminer typeDeterminer = getTypeDeterminer();
		if(setExpr.getMembers().size() > 0) {
			final ResultType resultType = typeDeterminer.determineType(setExpr.getMembers().get(0));
			for(int i = 1; i < setExpr.getMembers().size(); i++) {
				final ResultType newResultType = typeDeterminer.determineType(setExpr.getMembers().get(i));
				if(newResultType != resultType){
					error("All members of the set must be of the same type. Expected: " + resultType + ". Found: " + newResultType + ".", InputConstraintPackage.Literals.SET_EXPRESSION__MEMBERS);
				}
			}
		}
	}	
	
	@Check
	public void checkBinaryExpressionTypes(final BinaryExpression binaryExpr) {
		final InputConstraintTypeDeterminer typeDeterminer = getTypeDeterminer();
		final ResultType leftType = typeDeterminer.determineType(binaryExpr.getLeft());
		final ResultType rightType = typeDeterminer.determineType(binaryExpr.getRight());
		if(leftType != rightType) {
			error("Both sides of a binary expression must be of the same type. Left: " + leftType + ". Right: " + rightType + ".", InputConstraintPackage.Literals.BINARY_EXPRESSION__LEFT);
		} else if(leftType == ResultType.INTEGER && binaryExpr.getOp() == Operator.DIVISION) {
			error("Integer division is not supported.", InputConstraintPackage.Literals.BINARY_EXPRESSION__LEFT);
		}
	}
	
	@Check
	public void checkBoundedIntervalForFunction(final RandomIntegerExpression randExpr) {
		final IntervalExpression interval = randExpr.getInterval();
		if(interval.getLeft() == null || interval.getRight() == null) {
			error("Interval used with rand_int() must be bounded.", InputConstraintPackage.Literals.RANDOM_INTEGER_EXPRESSION__INTERVAL);
		}
	}
	
	@Check
	public void checkBoundedIntervalForFunction(final RandomRealExpression randExpr) {
		final IntervalExpression interval = randExpr.getInterval();
		if(interval.getLeft() == null || interval.getRight() == null) {
			error("Interval used with rand_real() must be bounded.", InputConstraintPackage.Literals.RANDOM_REAL_EXPRESSION__INTERVAL);
		}
	}
	
	@Check
	public void ensureCurrentFrameElementNotReferencedInRandomExpression(final ElementRefExpression refExpr) {
		for(EObject container = refExpr.eContainer(); container != null; container = container.eContainer()) {
			// If the expression is inside a PreExpression is should be allowed since it refers to a previous frame.
			if(container instanceof PreExpression) {
				break;
			}
			
			if(container instanceof RandomExpression) {
				error("Reference to current step not allowed inside of argument for random expression.", InputConstraintPackage.Literals.ELEMENT_REF_EXPRESSION__IDS);
				return;
			}
		}
	}
	
	@Check
	public void checkTopLevelType(final InputConstraint ic) {
		if(ic.eContainer() == null) {
			final ResultType expectedType = getExpectedType();
			if(expectedType != null) { // Expected type may be null to indicate that there isn't an expected type.
				final ResultType actualType = getTypeDeterminer().determineType(ic);
				if(actualType != null && expectedType != actualType) { // Null types usually indicate an invalid reference which will be reported separately.
					error("Expression is not of the expected type. Expected: " + expectedType + ". Actual: " + actualType + ".", null);
				}
			}
		}		
	}
	
	@Check
	public void ensurePreHasValidReference(final PreExpression preExpr) {
		if(preExpr.getRef() == null) {
			error("pre() must have a valid reference.", null);
		}
	}
	
	@Check
	public void ensurePreIsNotUsedOnFirstStep(final PreExpression preExpr) {
		if(getNumberOfPreviousSteps() == 0) {
			error("pre() is not allowed on the first step", null);
		}
	}
	
	private InputConstraintTypeDeterminer getTypeDeterminer() {
		if(typeDeterminer == null) {
			typeDeterminer = new InputConstraintTypeDeterminer(getReferenceResolver());
		}
		
		return typeDeterminer;
	}
	
	private ReferenceTypeResolver getReferenceResolver() {
		return (ReferenceTypeResolver)getContext().get(ReferenceTypeResolver.class);
	}
	
	private ResultType getExpectedType() {
		return (ResultType)getContext().get(CONTEXT_KEY_EXPECTED_TYPE);
	}
	
	private int getNumberOfPreviousSteps() {
		return (int)getContext().get(CONTEXT_KEY_NUMBER_OF_PREVIOUS_STEPS);
	}
}
